<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: OpenCL</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">3.4.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/de5/group__opencl.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCL</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Stan's OpenCL backend allows for computation to be executed in parallel on a GPU or in multithreaded CPUs. </p>
<p>It is meant to easily conform with <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> such that you can create and read from a <code>matrix_cl</code> by doing</p>
<div class="fragment"><div class="line">Eigen::MatrixXd A_eig = Eigen::MatrixXd::Random(10, 10);</div><div class="line">matrix_cl&lt;double&gt; A(A_eig);</div><div class="line">matrix_cl&lt;double&gt; B = <a class="code" href="../../d5/de5/group__opencl.html#gab445d52648b5e23086af72eb1c023ddf">to_matrix_cl</a>(A_eig);</div><div class="line">matrix_cl&lt;double&gt; C = <a class="code" href="../../dc/d5d/group__opencl__kernels.html#ga5ae68e5bc48b68de19e32fb11b6da400">cholesky_decompose</a>(A * B);</div><div class="line"><span class="comment">// Read back to eigen matrix.</span></div><div class="line">Eigen::MatrixXd C_eig = <a class="code" href="../../d5/de5/group__opencl.html#ga295cb4472dd319a8b48238c7468b72b6">from_matrix_cl</a>(C);</div><div class="line"></div><div class="line"><span class="comment">// Also for vectors and raw pointers of pointers</span></div><div class="line">std::vector&lt;var&gt; A_vec(10, 0);</div><div class="line">matrix_cl&lt;var&gt; B_var(A_vec, 10, 1);</div><div class="line"></div><div class="line"><a class="code" href="../../d4/d84/namespacestan_1_1math.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a>** A_vari= <span class="comment">// fill</span></div><div class="line">matrix_cl&lt;var&gt; B_vari(A_vari, 10, 1);</div></div><!-- fragment --><p>Execution is performed in async and Kernel operations are compounded and compiled Just In Time. This allows for a low amount of overhead when passing data to and from the device and executing computations.</p>
<p>For more details see the paper on Arvix. <a href="https://arxiv.org/pdf/1907.01063.pdf">https://arxiv.org/pdf/1907.01063.pdf</a> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d2/d3c/group__opencl__kernel__generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/group__opencl__kernel__generator.html">OpenCL Kernel Generator</a></td></tr>
<tr class="memdesc:d2/d3c/group__opencl__kernel__generator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpenCL kernel generator is used to combine multiple matrix operations into a single OpenCL kernel. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d34/group__matrix__cl__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d34/group__matrix__cl__group.html">Matrix</a></td></tr>
<tr class="memdesc:d3/d34/group__matrix__cl__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> class - allocates memory space on the OpenCL device. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d5f/group__opencl__context__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d5f/group__opencl__context__group.html">OpenCL Context</a></td></tr>
<tr class="memdesc:de/d5f/group__opencl__context__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for OpenCL Context: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d32/group__error__checks__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d32/group__error__checks__opencl.html">Error Checks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/def/group__kernel__executor__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/group__kernel__executor__opencl.html">Kernel Executor</a></td></tr>
<tr class="memdesc:dd/def/group__kernel__executor__opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kernel executor allows OpenCL kernels to be executed in async. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d5d/group__opencl__kernels"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5d/group__opencl__kernels.html">Custom OpenCL kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/de3/group__prim__fun__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de3/group__prim__fun__opencl.html">OpenCL overloads of stan/math/prim functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga55b628b5a271afb9f569c34187fd82ad">stan::math::opencl::cholesky_decompose</a> (matrix_cl&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga55b628b5a271afb9f569c34187fd82ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an in-place computation of the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <a href="../../d5/de5/group__opencl.html#ga55b628b5a271afb9f569c34187fd82ad">More...</a><br /></td></tr>
<tr class="separator:ga55b628b5a271afb9f569c34187fd82ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab445d52648b5e23086af72eb1c023ddf"><td class="memTemplParams" colspan="2">template&lt;typename T , require_vt_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab445d52648b5e23086af72eb1c023ddf"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; value_type_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab445d52648b5e23086af72eb1c023ddf">stan::math::to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="memdesc:gab445d52648b5e23086af72eb1c023ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, <code>std::vector</code> or scalar to the destination matrix that is stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#gab445d52648b5e23086af72eb1c023ddf">More...</a><br /></td></tr>
<tr class="separator:gab445d52648b5e23086af72eb1c023ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295cb4472dd319a8b48238c7468b72b6"><td class="memTemplParams" colspan="2">template&lt;int R = Eigen::Dynamic, int C = Eigen::Dynamic, typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga295cb4472dd319a8b48238c7468b72b6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; value_type_t&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga295cb4472dd319a8b48238c7468b72b6">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga295cb4472dd319a8b48238c7468b72b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix.  <a href="../../d5/de5/group__opencl.html#ga295cb4472dd319a8b48238c7468b72b6">More...</a><br /></td></tr>
<tr class="separator:ga295cb4472dd319a8b48238c7468b72b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30079b9eeb5dbb1992a7598c15329fcc"><td class="memTemplParams" colspan="2">template&lt;int R = Eigen::Dynamic, int C = Eigen::Dynamic, typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga30079b9eeb5dbb1992a7598c15329fcc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; value_type_t&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga30079b9eeb5dbb1992a7598c15329fcc">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga30079b9eeb5dbb1992a7598c15329fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies result of a kernel generator expression to the destination <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix.  <a href="../../d5/de5/group__opencl.html#ga30079b9eeb5dbb1992a7598c15329fcc">More...</a><br /></td></tr>
<tr class="separator:ga30079b9eeb5dbb1992a7598c15329fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga490df7651c22c9e06d09da69ad303e30">stan::math::packed_copy</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga490df7651c22c9e06d09da69ad303e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs the square flat triangular matrix on the OpenCL device and copies it to the std::vector.  <a href="../../d5/de5/group__opencl.html#ga490df7651c22c9e06d09da69ad303e30">More...</a><br /></td></tr>
<tr class="separator:ga490df7651c22c9e06d09da69ad303e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">stan::math::packed_copy</a> (Vec &amp;&amp;src, int rows)</td></tr>
<tr class="memdesc:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">More...</a><br /></td></tr>
<tr class="separator:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplItemLeft" align="right" valign="top">plain_type_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga60406331fe144c5088b62ab261a04e87">stan::math::copy_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga60406331fe144c5088b62ab261a04e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix to the destination matrix.  <a href="../../d5/de5/group__opencl.html#ga60406331fe144c5088b62ab261a04e87">More...</a><br /></td></tr>
<tr class="separator:ga60406331fe144c5088b62ab261a04e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513debd5fdb603fc031e9fd8e7999521"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga513debd5fdb603fc031e9fd8e7999521"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga513debd5fdb603fc031e9fd8e7999521">stan::math::from_matrix_cl_error_code</a> (const matrix_cl&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga513debd5fdb603fc031e9fd8e7999521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy A 1 by 1 source matrix from the Device to the host.  <a href="../../d5/de5/group__opencl.html#ga513debd5fdb603fc031e9fd8e7999521">More...</a><br /></td></tr>
<tr class="separator:ga513debd5fdb603fc031e9fd8e7999521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const matrix_cl_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9850bbd8d516b87d722ad54947bb9c9f">stan::math::either</a> (const matrix_cl_view left_view, const matrix_cl_view right_view)</td></tr>
<tr class="memdesc:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in any of the input views.  <a href="../../d5/de5/group__opencl.html#ga9850bbd8d516b87d722ad54947bb9c9f">More...</a><br /></td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const matrix_cl_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga338a285d4ba933ba6aa7240908919e0f">stan::math::both</a> (const matrix_cl_view left_view, const matrix_cl_view right_view)</td></tr>
<tr class="memdesc:ga338a285d4ba933ba6aa7240908919e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in both input views.  <a href="../../d5/de5/group__opencl.html#ga338a285d4ba933ba6aa7240908919e0f">More...</a><br /></td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadd63c8a601189c916c8a2157066adb7c">stan::math::contains_nonzero</a> (const matrix_cl_view view, const matrix_cl_view part)</td></tr>
<tr class="memdesc:gadd63c8a601189c916c8a2157066adb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a view contains certain nonzero part.  <a href="../../d5/de5/group__opencl.html#gadd63c8a601189c916c8a2157066adb7c">More...</a><br /></td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const matrix_cl_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gafccee2b081b9edd7c6e6d211157e5490">stan::math::transpose</a> (const matrix_cl_view view)</td></tr>
<tr class="memdesc:gafccee2b081b9edd7c6e6d211157e5490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a view - swaps lower and upper parts.  <a href="../../d5/de5/group__opencl.html#gafccee2b081b9edd7c6e6d211157e5490">More...</a><br /></td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const matrix_cl_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga747f014e58d824281b725a7d4868dd77">stan::math::invert</a> (const matrix_cl_view view)</td></tr>
<tr class="memdesc:ga747f014e58d824281b725a7d4868dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a view.  <a href="../../d5/de5/group__opencl.html#ga747f014e58d824281b725a7d4868dd77">More...</a><br /></td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top">matrix_cl_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga27e938e6fdd621c5903cc37401c54909">stan::math::from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="memdesc:ga27e938e6fdd621c5903cc37401c54909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view from <code>Eigen::UpLoType</code>.  <a href="../../d5/de5/group__opencl.html#ga27e938e6fdd621c5903cc37401c54909">More...</a><br /></td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga72e3539ba6e81a0a69e69f09c683252a">stan::math::multiply_transpose</a> (const matrix_cl&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga72e3539ba6e81a0a69e69f09c683252a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a square OpenCL matrix with its transpose.  <a href="../../d5/de5/group__opencl.html#ga72e3539ba6e81a0a69e69f09c683252a">More...</a><br /></td></tr>
<tr class="separator:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga41aad12d4ca13a5ae0117d586fb276bf">stan::math::bernoulli_logit_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;beta)</td></tr>
<tr class="memdesc:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <a href="../../d5/de5/group__opencl.html#ga41aad12d4ca13a5ae0117d586fb276bf">More...</a><br /></td></tr>
<tr class="separator:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4f362f28acd7dfc21fc0df158e8b4df8">stan::math::bernoulli_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Bernoulli distribution.  <a href="../../d5/de5/group__opencl.html#ga4f362f28acd7dfc21fc0df158e8b4df8">More...</a><br /></td></tr>
<tr class="separator:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6f3979f0dfb2cfe557bb00f5a420819d">stan::math::beta_lpdf</a> (const T_y_cl &amp;y, const T_scale_succ_cl &amp;alpha, const T_scale_fail_cl &amp;beta)</td></tr>
<tr class="memdesc:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for the specified scalar(s) given the specified sample stan::math::size(s).  <a href="../../d5/de5/group__opencl.html#ga6f3979f0dfb2cfe557bb00f5a420819d">More...</a><br /></td></tr>
<tr class="separator:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga695bf141835176b401725a1f93c0b00b">stan::math::beta_proportion_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_prec_cl &amp;kappa)</td></tr>
<tr class="memdesc:ga695bf141835176b401725a1f93c0b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for specified y, location, and precision: beta_proportion_lpdf(y | mu, kappa) = beta_lpdf(y | mu * kappa, (1 - mu) * kappa).  <a href="../../d5/de5/group__opencl.html#ga695bf141835176b401725a1f93c0b00b">More...</a><br /></td></tr>
<tr class="separator:ga695bf141835176b401725a1f93c0b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga12e355b2eb2a94840f0d2d8df923fc9a">stan::math::binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <a href="../../d5/de5/group__opencl.html#ga12e355b2eb2a94840f0d2d8df923fc9a">More...</a><br /></td></tr>
<tr class="separator:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga44d57691e9a780ada257fb9a3573f7d9">stan::math::categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;beta)</td></tr>
<tr class="memdesc:ga44d57691e9a780ada257fb9a3573f7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function.  <a href="../../d5/de5/group__opencl.html#ga44d57691e9a780ada257fb9a3573f7d9">More...</a><br /></td></tr>
<tr class="separator:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5e5bc2b295d24a0a13675f8f3465a224">stan::math::cauchy_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <a href="../../d5/de5/group__opencl.html#ga5e5bc2b295d24a0a13675f8f3465a224">More...</a><br /></td></tr>
<tr class="separator:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4c220c07244b0448c4743e1a447f27e3">stan::math::chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="memdesc:ga4c220c07244b0448c4743e1a447f27e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a chi-squared density for y with the specified degrees of freedom parameter.  <a href="../../d5/de5/group__opencl.html#ga4c220c07244b0448c4743e1a447f27e3">More...</a><br /></td></tr>
<tr class="separator:ga4c220c07244b0448c4743e1a447f27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0576c38beac678f1164a2cfc172e941e">stan::math::col</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="memdesc:ga0576c38beac678f1164a2cfc172e941e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified kernel generator expression using start-at-1 indexing.  <a href="../../d5/de5/group__opencl.html#ga0576c38beac678f1164a2cfc172e941e">More...</a><br /></td></tr>
<tr class="separator:ga0576c38beac678f1164a2cfc172e941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga89d4c5b2fb1164cd7dddf3d303785022">stan::math::cols</a> (const T_x &amp;x)</td></tr>
<tr class="memdesc:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the specified kernel generator expression.  <a href="../../d5/de5/group__opencl.html#ga89d4c5b2fb1164cd7dddf3d303785022">More...</a><br /></td></tr>
<tr class="separator:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaff473895b1f11e364afd4c2d3cb5cab4">stan::math::dims</a> (const T_x &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> overload of the dims helper function in <a class="el" href="../../d2/d7c/prim_2fun_2dims_8hpp.html">prim/fun/dims.hpp</a>.  <a href="../../d5/de5/group__opencl.html#gaff473895b1f11e364afd4c2d3cb5cab4">More...</a><br /></td></tr>
<tr class="separator:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7fcb23d1bea081595030aedd230f5cf9">stan::math::divide</a> (T_a &amp;&amp;a, double d)</td></tr>
<tr class="memdesc:ga7fcb23d1bea081595030aedd230f5cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise division of the kernel generator expression.  <a href="../../d5/de5/group__opencl.html#ga7fcb23d1bea081595030aedd230f5cf9">More...</a><br /></td></tr>
<tr class="separator:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc086d26daac255e9c18dc5216d99c1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga9dc086d26daac255e9c18dc5216d99c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9dc086d26daac255e9c18dc5216d99c1">stan::math::divide_columns</a> (const matrix_cl&lt; T1 &gt; &amp;A, const matrix_cl&lt; T2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ga9dc086d26daac255e9c18dc5216d99c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a vector.  <a href="../../d5/de5/group__opencl.html#ga9dc086d26daac255e9c18dc5216d99c1">More...</a><br /></td></tr>
<tr class="separator:ga9dc086d26daac255e9c18dc5216d99c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf223f44b8e6a13e709c0179127fa8f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:gadbf223f44b8e6a13e709c0179127fa8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadbf223f44b8e6a13e709c0179127fa8f">stan::math::divide_columns</a> (const matrix_cl&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="memdesc:gadbf223f44b8e6a13e709c0179127fa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a scalar.  <a href="../../d5/de5/group__opencl.html#gadbf223f44b8e6a13e709c0179127fa8f">More...</a><br /></td></tr>
<tr class="separator:gadbf223f44b8e6a13e709c0179127fa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga32141185398679bb00fe1ce2ba9b66c1">stan::math::double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga32141185398679bb00fe1ce2ba9b66c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log probability density function.  <a href="../../d5/de5/group__opencl.html#ga32141185398679bb00fe1ce2ba9b66c1">More...</a><br /></td></tr>
<tr class="separator:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2860333c4eb25602dc10a31f5f817fb1">stan::math::exp_mod_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga2860333c4eb25602dc10a31f5f817fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the exp mod normal distribution.  <a href="../../d5/de5/group__opencl.html#ga2860333c4eb25602dc10a31f5f817fb1">More...</a><br /></td></tr>
<tr class="separator:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaef8076d4800bf09044f6b2d3206ee8de">stan::math::exponential_lpdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;beta)</td></tr>
<tr class="memdesc:gaef8076d4800bf09044f6b2d3206ee8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an exponential density for y with the specified inverse scale parameter.  <a href="../../d5/de5/group__opencl.html#gaef8076d4800bf09044f6b2d3206ee8de">More...</a><br /></td></tr>
<tr class="separator:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga40919e3150ee05b80682f46cde802c22">stan::math::frechet_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga40919e3150ee05b80682f46cde802c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the frechet density for the specified scalar(s) given the specified sample stan::math::size(s).  <a href="../../d5/de5/group__opencl.html#ga40919e3150ee05b80682f46cde802c22">More...</a><br /></td></tr>
<tr class="separator:ga40919e3150ee05b80682f46cde802c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3964605bbb452f539ad82458a1a7cc07">stan::math::gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;beta)</td></tr>
<tr class="memdesc:ga3964605bbb452f539ad82458a1a7cc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a gamma density for y with the specified shape and inverse scale parameters.  <a href="../../d5/de5/group__opencl.html#ga3964605bbb452f539ad82458a1a7cc07">More...</a><br /></td></tr>
<tr class="separator:ga3964605bbb452f539ad82458a1a7cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; return_type_t&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa686087fcae5e7016b355ceb3cf45846">stan::math::gp_exp_quad_cov</a> (const matrix_cl&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:gaa686087fcae5e7016b355ceb3cf45846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <a href="../../d5/de5/group__opencl.html#gaa686087fcae5e7016b355ceb3cf45846">More...</a><br /></td></tr>
<tr class="separator:gaa686087fcae5e7016b355ceb3cf45846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; return_type_t&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9ebc1c13865b66015a0f30739b18b28f">stan::math::gp_exp_quad_cov</a> (const matrix_cl&lt; T1 &gt; &amp;x, const matrix_cl&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga9ebc1c13865b66015a0f30739b18b28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <a href="../../d5/de5/group__opencl.html#ga9ebc1c13865b66015a0f30739b18b28f">More...</a><br /></td></tr>
<tr class="separator:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa88407c66c8c8de7bf26c1d8eadaff84">stan::math::gumbel_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;beta)</td></tr>
<tr class="memdesc:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log probability density for the given location and scale.  <a href="../../d5/de5/group__opencl.html#gaa88407c66c8c8de7bf26c1d8eadaff84">More...</a><br /></td></tr>
<tr class="separator:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac32df5b5541df60cd45e329bf067f000">stan::math::inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="memdesc:gac32df5b5541df60cd45e329bf067f000"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse chi-squared density for y with the specified degrees of freedom parameter.  <a href="../../d5/de5/group__opencl.html#gac32df5b5541df60cd45e329bf067f000">More...</a><br /></td></tr>
<tr class="separator:gac32df5b5541df60cd45e329bf067f000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7e0332105689b4e9992e99166c4f3e12">stan::math::inv_gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;beta)</td></tr>
<tr class="memdesc:ga7e0332105689b4e9992e99166c4f3e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse gamma density for y with the specified shape and scale parameters.  <a href="../../d5/de5/group__opencl.html#ga7e0332105689b4e9992e99166c4f3e12">More...</a><br /></td></tr>
<tr class="separator:ga7e0332105689b4e9992e99166c4f3e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9aa767c6b4a5636db46932992cae075b">stan::math::logistic_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga9aa767c6b4a5636db46932992cae075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a logistic density for y with the specified location and scale parameters.  <a href="../../d5/de5/group__opencl.html#ga9aa767c6b4a5636db46932992cae075b">More...</a><br /></td></tr>
<tr class="separator:ga9aa767c6b4a5636db46932992cae075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae14854b2ed4e8eed637cdeb8f8d15dbb">stan::math::lognormal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the lognormal density for the specified scalar(s) given the specified sample stan::math::size(s).  <a href="../../d5/de5/group__opencl.html#gae14854b2ed4e8eed637cdeb8f8d15dbb">More...</a><br /></td></tr>
<tr class="separator:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; return_type_t&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6ed19f70ae3520d9ef8c982dace013e8">stan::math::multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices.  <a href="../../d5/de5/group__opencl.html#ga6ed19f70ae3520d9ef8c982dace013e8">More...</a><br /></td></tr>
<tr class="separator:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gacb16f794da8d9e6341f2543fbab56237">stan::math::neg_binomial_2_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;beta, const T_phi_cl &amp;phi)</td></tr>
<tr class="memdesc:gacb16f794da8d9e6341f2543fbab56237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function.  <a href="../../d5/de5/group__opencl.html#gacb16f794da8d9e6341f2543fbab56237">More...</a><br /></td></tr>
<tr class="separator:gacb16f794da8d9e6341f2543fbab56237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7c1c0e8c6edb035b297e73193f8cd820">stan::math::neg_binomial_2_log_lpmf</a> (const T_n_cl &amp;n, const T_log_location_cl &amp;eta, const T_precision_cl &amp;phi)</td></tr>
<tr class="memdesc:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the log transformed negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <a href="../../d5/de5/group__opencl.html#ga7c1c0e8c6edb035b297e73193f8cd820">More...</a><br /></td></tr>
<tr class="separator:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0f3956bcf1b6e3aac673b7b89f2f9b4d">stan::math::neg_binomial_2_lpmf</a> (const T_n_cl &amp;n, const T_location_cl &amp;mu, const T_precision_cl &amp;phi)</td></tr>
<tr class="memdesc:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <a href="../../d5/de5/group__opencl.html#ga0f3956bcf1b6e3aac673b7b89f2f9b4d">More...</a><br /></td></tr>
<tr class="separator:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaacb77966b5ca780cac193dfeb6e7dc7f">stan::math::neg_binomial_lpmf</a> (const T_n_cl &amp;n, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;beta)</td></tr>
<tr class="memdesc:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <a href="../../d5/de5/group__opencl.html#gaacb77966b5ca780cac193dfeb6e7dc7f">More...</a><br /></td></tr>
<tr class="separator:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf3c799735f974356f8d1ab7743960a65">stan::math::normal_id_glm_lpdf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;beta, const T_sigma_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaf3c799735f974356f8d1ab7743960a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function.  <a href="../../d5/de5/group__opencl.html#gaf3c799735f974356f8d1ab7743960a65">More...</a><br /></td></tr>
<tr class="separator:gaf3c799735f974356f8d1ab7743960a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab98a15165135ddb986e4f74cb66817ba">stan::math::normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gab98a15165135ddb986e4f74cb66817ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s).  <a href="../../d5/de5/group__opencl.html#gab98a15165135ddb986e4f74cb66817ba">More...</a><br /></td></tr>
<tr class="separator:gab98a15165135ddb986e4f74cb66817ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga363eead878eb45fb01517e94ac7d4f4b">stan::math::ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;beta, const T_cuts &amp;cuts)</td></tr>
<tr class="memdesc:ga363eead878eb45fb01517e94ac7d4f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the ordinal regression Generalized Linear Model (GLM).  <a href="../../d5/de5/group__opencl.html#ga363eead878eb45fb01517e94ac7d4f4b">More...</a><br /></td></tr>
<tr class="separator:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7b5e8eec1c27b30ea994f94070adc148">stan::math::pareto_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga7b5e8eec1c27b30ea994f94070adc148"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <a href="../../d5/de5/group__opencl.html#ga7b5e8eec1c27b30ea994f94070adc148">More...</a><br /></td></tr>
<tr class="separator:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga83a333811247fce0ea707ce959dffa38">stan::math::pareto_type_2_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga83a333811247fce0ea707ce959dffa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Pareto type 2 distribution.  <a href="../../d5/de5/group__opencl.html#ga83a333811247fce0ea707ce959dffa38">More...</a><br /></td></tr>
<tr class="separator:ga83a333811247fce0ea707ce959dffa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gacd6c49794202989a029ff70567f55479">stan::math::poisson_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;beta)</td></tr>
<tr class="memdesc:gacd6c49794202989a029ff70567f55479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function.  <a href="../../d5/de5/group__opencl.html#gacd6c49794202989a029ff70567f55479">More...</a><br /></td></tr>
<tr class="separator:gacd6c49794202989a029ff70567f55479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_log_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5b1dba179f6258a2e07a30bdbe97255a">stan::math::poisson_log_lpmf</a> (const T_n_cl &amp;n, const T_log_rate_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Poisson log distribution.  <a href="../../d5/de5/group__opencl.html#ga5b1dba179f6258a2e07a30bdbe97255a">More...</a><br /></td></tr>
<tr class="separator:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gabfdbbaacbab1d90d71290edc806bace3">stan::math::poisson_lpmf</a> (const T_n_cl &amp;n, const T_rate_cl &amp;lambda)</td></tr>
<tr class="memdesc:gabfdbbaacbab1d90d71290edc806bace3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Poisson distribution.  <a href="../../d5/de5/group__opencl.html#gabfdbbaacbab1d90d71290edc806bace3">More...</a><br /></td></tr>
<tr class="separator:gabfdbbaacbab1d90d71290edc806bace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga601d163c824e05147660da53e4099bd9">stan::math::rayleigh_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga601d163c824e05147660da53e4099bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an Rayleigh density for y with the specified scale parameter.  <a href="../../d5/de5/group__opencl.html#ga601d163c824e05147660da53e4099bd9">More...</a><br /></td></tr>
<tr class="separator:ga601d163c824e05147660da53e4099bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480e7b2d228e7bb71d6160c87349464a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga480e7b2d228e7bb71d6160c87349464a"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga480e7b2d228e7bb71d6160c87349464a">stan::math::rep_matrix</a> (const matrix_cl&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="memdesc:ga480e7b2d228e7bb71d6160c87349464a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> by replicating the value of the only element in the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>.  <a href="../../d5/de5/group__opencl.html#ga480e7b2d228e7bb71d6160c87349464a">More...</a><br /></td></tr>
<tr class="separator:ga480e7b2d228e7bb71d6160c87349464a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9619e09e2ee9450bbcc70f11a8076668"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga9619e09e2ee9450bbcc70f11a8076668"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9619e09e2ee9450bbcc70f11a8076668">stan::math::rep_matrix</a> (const matrix_cl&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga9619e09e2ee9450bbcc70f11a8076668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> by replicating the input vector or row_vector.  <a href="../../d5/de5/group__opencl.html#ga9619e09e2ee9450bbcc70f11a8076668">More...</a><br /></td></tr>
<tr class="separator:ga9619e09e2ee9450bbcc70f11a8076668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f940240b9c947f73f5871c9fbaed378"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5f940240b9c947f73f5871c9fbaed378"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5f940240b9c947f73f5871c9fbaed378">stan::math::rep_row_vector</a> (const matrix_cl&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga5f940240b9c947f73f5871c9fbaed378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> representing a row_vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>.  <a href="../../d5/de5/group__opencl.html#ga5f940240b9c947f73f5871c9fbaed378">More...</a><br /></td></tr>
<tr class="separator:ga5f940240b9c947f73f5871c9fbaed378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5cacb7a3b780ce375aec0449229e03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1c5cacb7a3b780ce375aec0449229e03"><td class="memTemplItemLeft" align="right" valign="top">matrix_cl&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1c5cacb7a3b780ce375aec0449229e03">stan::math::rep_vector</a> (const matrix_cl&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga1c5cacb7a3b780ce375aec0449229e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> representing a vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>.  <a href="../../d5/de5/group__opencl.html#ga1c5cacb7a3b780ce375aec0449229e03">More...</a><br /></td></tr>
<tr class="separator:ga1c5cacb7a3b780ce375aec0449229e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga80392ae5670adea53e79770aa29c816a">stan::math::row</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="memdesc:ga80392ae5670adea53e79770aa29c816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified kernel generator expression using start-at-1 indexing.  <a href="../../d5/de5/group__opencl.html#ga80392ae5670adea53e79770aa29c816a">More...</a><br /></td></tr>
<tr class="separator:ga80392ae5670adea53e79770aa29c816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">stan::math::rows</a> (const T_x &amp;x)</td></tr>
<tr class="memdesc:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the specified kernel generator expression.  <a href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">More...</a><br /></td></tr>
<tr class="separator:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga106d028bb360d5c31554ec3495cc41d0">stan::math::scaled_inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_scale_cl &amp;s)</td></tr>
<tr class="memdesc:ga106d028bb360d5c31554ec3495cc41d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <a href="../../d5/de5/group__opencl.html#ga106d028bb360d5c31554ec3495cc41d0">More...</a><br /></td></tr>
<tr class="separator:ga106d028bb360d5c31554ec3495cc41d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gac950822e01ad7173a9f42c571933eb06">stan::math::skew_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:gac950822e01ad7173a9f42c571933eb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the skew normal density for the specified scalar(s) given the specified mean(s), deviation(s) and shape(s).  <a href="../../d5/de5/group__opencl.html#gac950822e01ad7173a9f42c571933eb06">More...</a><br /></td></tr>
<tr class="separator:gac950822e01ad7173a9f42c571933eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga48200e7b64861fad93fcdf7b24c8cac4">stan::math::std_normal_lpdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given a location of 0 and a scale of 1.  <a href="../../d5/de5/group__opencl.html#ga48200e7b64861fad93fcdf7b24c8cac4">More...</a><br /></td></tr>
<tr class="separator:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8a3e85cdcb831735bf845adf1c42e234">stan::math::student_t_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga8a3e85cdcb831735bf845adf1c42e234"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Student-t density for the given y, nu, mean, and scale parameter.  <a href="../../d5/de5/group__opencl.html#ga8a3e85cdcb831735bf845adf1c42e234">More...</a><br /></td></tr>
<tr class="separator:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8c081c9922500bedd293b98080c246a9">stan::math::uniform_lpdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;beta)</td></tr>
<tr class="memdesc:ga8c081c9922500bedd293b98080c246a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a uniform density for the given y, lower, and upper bound.  <a href="../../d5/de5/group__opencl.html#ga8c081c9922500bedd293b98080c246a9">More...</a><br /></td></tr>
<tr class="separator:ga8c081c9922500bedd293b98080c246a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplItemLeft" align="right" valign="top">return_type_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9ecf070a86a3bb30c08ced16a1c1bb32">stan::math::weibull_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull log probability density for the given location and scale.  <a href="../../d5/de5/group__opencl.html#ga9ecf070a86a3bb30c08ced16a1c1bb32">More...</a><br /></td></tr>
<tr class="separator:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplItemLeft" align="right" valign="top">var_value&lt; matrix_cl&lt; value_type_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga46313382ff3fae62c662662f93290572">stan::math::to_matrix_cl</a> (const var_value&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga46313382ff3fae62c662662f93290572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var containing <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices to destination var that has data stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#ga46313382ff3fae62c662662f93290572">More...</a><br /></td></tr>
<tr class="separator:ga46313382ff3fae62c662662f93290572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8837ecfc67bc2624979c3633d76411"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0c8837ecfc67bc2624979c3633d76411"><td class="memTemplItemLeft" align="right" valign="top">var_value&lt; matrix_cl&lt; value_type_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0c8837ecfc67bc2624979c3633d76411">stan::math::to_matrix_cl</a> (std::vector&lt; var_value&lt; T &gt;&gt; &amp;a)</td></tr>
<tr class="memdesc:ga0c8837ecfc67bc2624979c3633d76411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source std::vector of vars to a destination var that has data stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#ga0c8837ecfc67bc2624979c3633d76411">More...</a><br /></td></tr>
<tr class="separator:ga0c8837ecfc67bc2624979c3633d76411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbde57e8fc7689d4c8c708610511a6fa"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic, typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadbde57e8fc7689d4c8c708610511a6fa"><td class="memTemplItemLeft" align="right" valign="top">var_value&lt; Eigen::Matrix&lt; value_type_t&lt; T &gt;, Rows, Cols &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadbde57e8fc7689d4c8c708610511a6fa">stan::math::from_matrix_cl</a> (const var_value&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:gadbde57e8fc7689d4c8c708610511a6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination var containing <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices.  <a href="../../d5/de5/group__opencl.html#gadbde57e8fc7689d4c8c708610511a6fa">More...</a><br /></td></tr>
<tr class="separator:gadbde57e8fc7689d4c8c708610511a6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplItemLeft" align="right" valign="top">var_value&lt; matrix_cl&lt; value_type_t&lt; value_type_t&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga095903e22c477b60e69e174c307bd423">stan::math::to_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga095903e22c477b60e69e174c307bd423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix of vars to the destination matrix that is stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#ga095903e22c477b60e69e174c307bd423">More...</a><br /></td></tr>
<tr class="separator:ga095903e22c477b60e69e174c307bd423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , require_matrix_cl_st&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplItemLeft" align="right" valign="top">plain_type_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga57ff9a795bfa5ae75421d00a95e8a6c0">stan::math::tri_inverse</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a triangular matrix.  <a href="../../d5/de5/group__opencl.html#ga57ff9a795bfa5ae75421d00a95e8a6c0">More...</a><br /></td></tr>
<tr class="separator:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga41aad12d4ca13a5ae0117d586fb276bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x_cl, T_alpha_cl, T_beta_cl&gt; stan::math::bernoulli_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function. </p>
<p>This is an overload of the GLM in <a class="el" href="../../d2/d4c/prim_2prob_2bernoulli__logit__glm__lpmf_8hpp.html">prim/prob/bernoulli_logit_glm_lpmf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>binary scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not binary. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dfd/opencl_2prim_2bernoulli__logit__glm__lpmf_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../d6/dfd/opencl_2prim_2bernoulli__logit__glm__lpmf_8hpp_source.html">bernoulli_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f362f28acd7dfc21fc0df158e8b4df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob_cl&gt; stan::math::bernoulli_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob_cl &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Bernoulli distribution. </p>
<p>If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of integer parameters </td></tr>
    <tr><td class="paramname">T_prob_cl</td><td>type of chance of success parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>integer parameter </td></tr>
    <tr><td class="paramname">theta</td><td>chance of success parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if theta is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/d6d/opencl_2prim_2bernoulli__lpmf_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../d1/d6d/opencl_2prim_2bernoulli__lpmf_8hpp_source.html">bernoulli_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f3979f0dfb2cfe557bb00f5a420819d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_scale_succ_cl, T_scale_fail_cl&gt; stan::math::beta_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the beta density for the specified scalar(s) given the specified sample stan::math::size(s). </p>
<p>y, alpha, or beta can each either be scalar or a vector on OpenCL device. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/alpha/beta triple.</p>
<p>Prior sample sizes, alpha and beta, must be greater than 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_succ_cl</td><td>type of prior scale for successes </td></tr>
    <tr><td class="paramname">T_scale_fail_cl</td><td>type of prior scale for failures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p>Definition at line <a class="el" href="../../d1/d82/opencl_2prim_2beta__lpdf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d1/d82/opencl_2prim_2beta__lpdf_8hpp_source.html">beta_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga695bf141835176b401725a1f93c0b00b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_prec_cl&gt; stan::math::beta_proportion_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prec_cl &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the beta density for specified y, location, and precision: beta_proportion_lpdf(y | mu, kappa) = beta_lpdf(y | mu * kappa, (1 - mu) * kappa). </p>
<p>Any arguments other than scalars must be containers of the same size. With non-scalar arguments, the return is the sum of the log pdfs with scalars broadcast as necessary.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/kappa triple.</p>
<p>Prior location, mu, must be contained in (0, 1). Prior precision must be positive.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of prior location </td></tr>
    <tr><td class="paramname">T_prec_cl</td><td>type of prior precision</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) dependant variable(s) </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">kappa</td><td>(Sequence of) precision parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p>Definition at line <a class="el" href="../../db/dd8/opencl_2prim_2beta__proportion__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../db/dd8/opencl_2prim_2beta__proportion__lpdf_8hpp_source.html">beta_proportion_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga12e355b2eb2a94840f0d2d8df923fc9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_prob_cl&gt; stan::math::binomial_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N_cl&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob_cl &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF for the binomial distribution evaluated at the specified success, population size, and chance of success. </p>
<p>If given containers of matching lengths, returns the log sum of probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of successes parameter </td></tr>
    <tr><td class="paramname">T_N_cl</td><td>type of population size parameter </td></tr>
    <tr><td class="paramname">T_prob_cl</td><td>type of chance of success parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>successes parameter </td></tr>
    <tr><td class="paramname">N</td><td>population size parameter </td></tr>
    <tr><td class="paramname">theta</td><td>chance of success parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if n is negative or greater than N </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if N is negative </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if theta is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../db/d48/opencl_2prim_2binomial__lpmf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../db/d48/opencl_2prim_2binomial__lpmf_8hpp_source.html">binomial_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga338a285d4ba933ba6aa7240908919e0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const matrix_cl_view stan::math::both </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which parts are nonzero in both input views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>common nonzero part </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga44d57691e9a780ada257fb9a3573f7d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_alpha, T_beta&gt; stan::math::categorical_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function. </p>
<p>This is an overload of the GLM in <a class="el" href="../../df/d55/prim_2prob_2categorical__logit__glm__lpmf_8hpp.html">prim/prob/categorical_logit_glm_lpmf.hpp</a> that is implemented in OpenCL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha</td><td>type of the intercept vector </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the matrix of weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar or vector of classes. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept vector (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>x, beta or alpha is infinite or y is not within bounds </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d91/opencl_2prim_2categorical__logit__glm__lpmf_8hpp_source.html#l00048">48</a> of file <a class="el" href="../../d5/d91/opencl_2prim_2categorical__logit__glm__lpmf_8hpp_source.html">categorical_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e5bc2b295d24a0a13675f8f3465a224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::cauchy_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s). </p>
<p>y, mu, or sigma can each either be scalar a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/sigma triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d25/opencl_2prim_2cauchy__lpdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d8/d25/opencl_2prim_2cauchy__lpdf_8hpp_source.html">cauchy_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c220c07244b0448c4743e1a447f27e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_dof_cl&gt; stan::math::chi_square_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a chi-squared density for y with the specified degrees of freedom parameter. </p>
<p>The degrees of freedom parameter must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \chi^2_\nu \\ \log (p (y \, |\, \nu)) &amp;=&amp; \log \left( \frac{2^{-\nu / 2}}{\Gamma (\nu / 2)} y^{\nu / 2 - 1} \exp^{- y / 2} \right) \\ &amp;=&amp; - \frac{\nu}{2} \log(2) - \log (\Gamma (\nu / 2)) + (\frac{\nu}{2} - 1) \log(y) - \frac{y}{2} \\ &amp; &amp; \mathrm{ where } \; y \ge 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dependent variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than or equal to 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d0a/opencl_2prim_2chi__square__lpdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d5/d0a/opencl_2prim_2chi__square__lpdf_8hpp_source.html">chi_square_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga55b628b5a271afb9f569c34187fd82ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::opencl::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an in-place computation of the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix. </p>
<p>The return value \(L\) will be a lower-triangular matrix such that the original matrix \(A\) is given by </p>
<p>\(A = L \times L^T\). The Cholesky decomposition is computed using an OpenCL kernel. This algorithm is recursive. The matrix is subset into a matrix of size <code><a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e" title="Returns the number of rows in the specified kernel generator expression. ">A.rows()</a> / 4</code>, and if the submatrix size is less than 50 or <code>min_block</code> then the Cholesky decomposition on the OpenCL device is computed using that submatrix. If the submatrix is greater than 50 or <code>min_block</code> then <code>cholesky_decompose</code> is run again on a submatrix with size equal to <code><a class="el" href="../../d5/de5/group__opencl.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e" title="Returns the number of rows in the specified kernel generator expression. ">submat.rows()</a> / 4</code>. Once the Cholesky decomposition is computed, the full matrix Cholesky is created by propagating the Cholesky forward as given in the reference report below.</p>
<p>For a full guide to how this works see the Cholesky decomposition chapter in the reference report <a href="https://goo.gl/6kWkJ5">here</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m is not positive definite (if m has more than 0 elements) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/df1/opencl_2cholesky__decompose_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d7/df1/opencl_2cholesky__decompose_8hpp_source.html">cholesky_decompose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0576c38beac678f1164a2cfc172e941e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::col </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified column of the specified kernel generator expression using start-at-1 indexing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression a </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression. </td></tr>
    <tr><td class="paramname">j</td><td>Column index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified column of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if j is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/dc8/opencl_2prim_2col_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d0/dc8/opencl_2prim_2col_8hpp_source.html">col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga89d4c5b2fb1164cd7dddf3d303785022"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::cols </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the specified kernel generator expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression x </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of columns in x </dd></dl>

<p>Definition at line <a class="el" href="../../db/de0/opencl_2prim_2cols_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../db/de0/opencl_2prim_2cols_8hpp_source.html">cols.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadd63c8a601189c916c8a2157066adb7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::contains_nonzero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a view contains certain nonzero part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to check </td></tr>
    <tr><td class="paramname">part</td><td>part to check for (usually <code>Lower</code> or <code>Upper</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if <code>view</code> has <code>part</code> nonzero </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga60406331fe144c5088b62ab261a04e87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plain_type_t&lt;T&gt; stan::math::copy_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source matrix to the destination matrix. </p>
<p>Both matrices are stored on the OpenCL device.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> with copies of values in the source matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrices do not have matching dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00231">231</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaff473895b1f11e364afd4c2d3cb5cab4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> overload of the dims helper function in <a class="el" href="../../d2/d7c/prim_2fun_2dims_8hpp.html">prim/fun/dims.hpp</a>. </p>
<p>Pushes the rows and columns to the result vector argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression a </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the input <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>the output vector of dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/dd9/opencl_2prim_2dims_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../d5/dd9/opencl_2prim_2dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7fcb23d1bea081595030aedd230f5cf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">T_a &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elementwise division of the kernel generator expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_a</td><td>type of input kernel generator expression a </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>expression to divide </td></tr>
    <tr><td class="paramname">d</td><td>scalar to divide by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the elements of expression a divided by d </dd></dl>

<p>Definition at line <a class="el" href="../../d6/d89/opencl_2prim_2divide_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../d6/d89/opencl_2prim_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9dc086d26daac255e9c18dc5216d99c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::divide_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each column of a matrix by a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramname">B</td><td>Vector of elements to divide each column of <code>A</code> by element-wise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element-wise division of <code>A</code> by <code>B</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the input matrices do not have matching dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html">divide_columns.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadbf223f44b8e6a13e709c0179127fa8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::divide_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each column of a matrix by a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to divide </td></tr>
    <tr><td class="paramname">divisor</td><td>scalar to divide by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element-wise division of <code>A</code> by <code>divisor</code>. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html">divide_columns.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga32141185398679bb00fe1ce2ba9b66c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::double_exponential_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the double exponential log probability density function. </p>
<p>Given containers of matching sizes, returns the log sum of densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of real parameter. </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter. </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>real parameter </td></tr>
    <tr><td class="paramname">mu</td><td>location parameter </td></tr>
    <tr><td class="paramname">sigma</td><td>scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability density or log sum of probability densities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is nan, mu is infinite, or sigma is nonpositive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d9c/opencl_2prim_2double__exponential__lpdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d5/d9c/opencl_2prim_2double__exponential__lpdf_8hpp_source.html">double_exponential_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9850bbd8d516b87d722ad54947bb9c9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const matrix_cl_view stan::math::either </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which parts are nonzero in any of the input views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga2860333c4eb25602dc10a31f5f817fb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl&gt; stan::math::exp_mod_normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the exp mod normal distribution. </p>
<p>If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>dependent variable </td></tr>
    <tr><td class="paramname">mu</td><td>location </td></tr>
    <tr><td class="paramname">sigma</td><td>scale </td></tr>
    <tr><td class="paramname">lambda</td><td>inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is NaN, mu is infinite, sigma is negative or infinite or lambda is negative or infinite. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/dc0/opencl_2prim_2exp__mod__normal__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/dc0/opencl_2prim_2exp__mod__normal__lpdf_8hpp_source.html">exp_mod_normal_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaef8076d4800bf09044f6b2d3206ee8de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_inv_scale_cl&gt; stan::math::exponential_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an exponential density for y with the specified inverse scale parameter. </p>
<p>Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Expon}}(\beta) \\ \log (p (y \, |\, \beta) ) &amp;=&amp; \log \left( \beta \exp^{-\beta y} \right) \\ &amp;=&amp; \log (\beta) - \beta y \\ &amp; &amp; \mathrm{where} \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/db8/opencl_2prim_2exponential__lpdf_8hpp_source.html#l00047">47</a> of file <a class="el" href="../../d2/db8/opencl_2prim_2exponential__lpdf_8hpp_source.html">exponential_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga40919e3150ee05b80682f46cde802c22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::frechet_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the frechet density for the specified scalar(s) given the specified sample stan::math::size(s). </p>
<p>y, alpha, or sigma can each either be scalar or a vector on OpenCL device. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/alpha/sigma triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>shape </td></tr>
    <tr><td class="paramname">sigma</td><td>scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p>Definition at line <a class="el" href="../../d9/dc6/opencl_2prim_2frechet__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d9/dc6/opencl_2prim_2frechet__lpdf_8hpp_source.html">frechet_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga27e938e6fdd621c5903cc37401c54909"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl_view stan::math::from_eigen_uplo_type </td>
          <td>(</td>
          <td class="paramtype">Eigen::UpLoType&#160;</td>
          <td class="paramname"><em>eigen_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view from <code>Eigen::UpLoType</code>. </p>
<p><code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">Eigen::Lower</a></code>, <code>Eigen::StrictlyLower</code> and <code>Eigen::UnitLower</code> become <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">PartialViewCL::Lower</a></code>. Similar for <code>Upper</code>. Any other view becomes <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">PartialViewCL::Entire</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigen_type</td><td><code>UpLoType</code> to create a view from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00086">86</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga295cb4472dd319a8b48238c7468b72b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R = Eigen::Dynamic, int C = Eigen::Dynamic, typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;value_type_t&lt;T&gt;, R, C&gt; stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with a copy of the data in the source matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00058">58</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadbde57e8fc7689d4c8c708610511a6fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic, typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">var_value&lt;Eigen::Matrix&lt;value_type_t&lt;T&gt;, Rows, Cols&gt; &gt; stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source var that has data stored on the OpenCL device to destination var containing <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>number of compile time rows of the destination matrix </td></tr>
    <tr><td class="paramname">Rows</td><td>number of compile time columns of the destination matrix </td></tr>
    <tr><td class="paramname">T</td><td>type of the matrix or expression on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the host </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga30079b9eeb5dbb1992a7598c15329fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R = Eigen::Dynamic, int C = Eigen::Dynamic, typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;value_type_t&lt;T&gt;, R, C&gt; stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies result of a kernel generator expression to the destination <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>rows type of the destination </td></tr>
    <tr><td class="paramname">C</td><td>cols type of the destination </td></tr>
    <tr><td class="paramname">T</td><td>type of expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with a copy of the data in the source matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00128">128</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga513debd5fdb603fc031e9fd8e7999521"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::from_matrix_cl_error_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy A 1 by 1 source matrix from the Device to the host. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A 1x1 matrix on the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dst Arithmetic to receive the <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> value. </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00242">242</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3964605bbb452f539ad82458a1a7cc07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_shape_cl, T_inv_scale_cl&gt; stan::math::gamma_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a gamma density for y with the specified shape and inverse scale parameters. </p>
<p>Shape and inverse scale parameters must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Gamma}}(\alpha, \beta) \\ \log (p (y \, |\, \alpha, \beta) ) &amp;=&amp; \log \left( \frac{\beta^\alpha}{\Gamma(\alpha)} y^{\alpha - 1} \exp^{- \beta y} \right) \\ &amp;=&amp; \alpha \log(\beta) - \log(\Gamma(\alpha)) + (\alpha - 1) \log(y) - \beta y\\ &amp; &amp; \mathrm{where} \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d44/opencl_2prim_2gamma__lpdf_8hpp_source.html#l00047">47</a> of file <a class="el" href="../../df/d44/opencl_2prim_2gamma__lpdf_8hpp_source.html">gamma_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa686087fcae5e7016b355ceb3cf45846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;return_type_t&lt;T1, T2, T3&gt; &gt; stan::math::gp_exp_quad_cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squared exponential kernel on the GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x. </dd></dl>

<p>Definition at line <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html">gp_exp_quad_cov.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ebc1c13865b66015a0f30739b18b28f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;return_type_t&lt;T1, T2, T3, T4&gt; &gt; stan::math::gp_exp_quad_cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squared exponential kernel on the GPU. </p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x and y. </dd></dl>

<p>Definition at line <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html#l00060">60</a> of file <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html">gp_exp_quad_cov.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa88407c66c8c8de7bf26c1d8eadaff84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::gumbel_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Gumbel log probability density for the given location and scale. </p>
<p>Given containers of matching sizes, returns the log sum of densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of real parameter </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>real parameter </td></tr>
    <tr><td class="paramname">mu</td><td>location parameter </td></tr>
    <tr><td class="paramname">beta</td><td>scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability density or log sum of probability densities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is nan, mu is infinite, or beta is nonpositive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/d6f/opencl_2prim_2gumbel__lpdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="../../d3/d6f/opencl_2prim_2gumbel__lpdf_8hpp_source.html">gumbel_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac32df5b5541df60cd45e329bf067f000"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_dof_cl&gt; stan::math::inv_chi_square_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an inverse chi-squared density for y with the specified degrees of freedom parameter. </p>
<p>The degrees of freedom parameter must be greater than 0. y must be greater than 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Inv-}}\chi^2_\nu \\ \log (p (y \, |\, \nu)) &amp;=&amp; \log \left( \frac{2^{-\nu / 2}}{\Gamma (\nu / 2)} y^{- (\nu / 2 + 1)} \exp^{-1 / (2y)} \right) \\ &amp;=&amp; - \frac{\nu}{2} \log(2) - \log (\Gamma (\nu / 2)) - (\frac{\nu}{2} + 1) \log(y) - \frac{1}{2y} \\ &amp; &amp; \mathrm{ where } \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than or equal to 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/db7/opencl_2prim_2inv__chi__square__lpdf_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../dc/db7/opencl_2prim_2inv__chi__square__lpdf_8hpp_source.html">inv_chi_square_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e0332105689b4e9992e99166c4f3e12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::inv_gamma_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an inverse gamma density for y with the specified shape and scale parameters. </p>
<p>Shape and scale parameters must be greater than 0. y must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_shape</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/d2a/opencl_2prim_2inv__gamma__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/d2a/opencl_2prim_2inv__gamma__lpdf_8hpp_source.html">inv_gamma_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga747f014e58d824281b725a7d4868dd77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const matrix_cl_view stan::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts a view. </p>
<p>Parts that are zero in the input become nonzero in output and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverted view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00071">71</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9aa767c6b4a5636db46932992cae075b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::logistic_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a logistic density for y with the specified location and scale parameters. </p>
<p>Shape and scale parameters must be greater than 0. y must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">mu</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">sigma</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if mu is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/de7/opencl_2prim_2logistic__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../d6/de7/opencl_2prim_2logistic__lpdf_8hpp_source.html">logistic_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae14854b2ed4e8eed637cdeb8f8d15dbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::lognormal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the lognormal density for the specified scalar(s) given the specified sample stan::math::size(s). </p>
<p>y, mu, or sigma can each either be scalar or a vector on OpenCL device. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/sigma triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of prior scale for successes </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of prior scale for failures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) prior sample stan::math::size(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d41/opencl_2prim_2lognormal__lpdf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../dc/d41/opencl_2prim_2lognormal__lpdf_8hpp_source.html">lognormal_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ed19f70ae3520d9ef8c982dace013e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;return_type_t&lt;T1, T2&gt; &gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices. </p>
<p>Computes the matrix multiplication C[M, K] = A[M, N] x B[N, K]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramname">B</td><td>second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">partial_view_A</td><td>specifies whether the matrix A is a lower/upper triangular or a rectangular matrix </td></tr>
    <tr><td class="paramname">partial_view_B</td><td>specifies whether the matrix B is a lower/upper triangular or a rectangular matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the first and second matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the number of columns in A and rows in B do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d62/opencl_2prim_2multiply_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../d4/d62/opencl_2prim_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga72e3539ba6e81a0a69e69f09c683252a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;T&gt; stan::math::multiply_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the product of a square OpenCL matrix with its transpose. </p>
<p>Computes the matrix multiplication C = A x A^T</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the input matrix and its transpose </dd></dl>

<p>Definition at line <a class="el" href="../../d7/d28/multiply__transpose_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d7/d28/multiply__transpose_8hpp_source.html">multiply_transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacb16f794da8d9e6341f2543fbab56237"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl&gt; stan::math::neg_binomial_2_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_phi_cl &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function. </p>
<p>The idea is that neg_binomial_2_log_glm_lpmf(y, x, alpha, beta, phi) should compute a more efficient version of neg_binomial_2_log_lpmf(y, alpha + x * beta, phi) by using analytically simplified gradients. If containers are supplied, returns the log sum of the probabilities. This is an overload of the GLM in prim/prob/neg_binomial_2_log_glm_lpdf.hpp that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; this can also be a scalar; </td></tr>
    <tr><td class="paramname">T_phi_cl</td><td>type of the (positive) precision(s); this can be a vector (of the same length as y, for heteroskedasticity) or a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>failures count scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">phi</td><td>(vector of) precision parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if phi is infinite or non-positive. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/def/opencl_2prim_2neg__binomial__2__log__glm__lpmf_8hpp_source.html#l00069">69</a> of file <a class="el" href="../../d5/def/opencl_2prim_2neg__binomial__2__log__glm__lpmf_8hpp_source.html">neg_binomial_2_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c1c0e8c6edb035b297e73193f8cd820"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_n_cl, T_log_location_cl, T_precision_cl&gt; stan::math::neg_binomial_2_log_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_location_cl &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision_cl &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the log transformed negative binomial density for the specified scalars given the specified mean(s) and deviation(s). </p>
<p>n, eta, or phi can each be either a scalar or a vector <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_log_location_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_precision_cl</td><td>type of precision parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">eta</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">phi</td><td>(Sequence of) precision parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/dc2/opencl_2prim_2neg__binomial__2__log__lpmf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../de/dc2/opencl_2prim_2neg__binomial__2__log__lpmf_8hpp_source.html">neg_binomial_2_log_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f3956bcf1b6e3aac673b7b89f2f9b4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_n_cl, T_location_cl, T_precision_cl&gt; stan::math::neg_binomial_2_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision_cl &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s). </p>
<p>n, mu, or phi can each be either a scalar or a vector <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_location_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_precision_cl</td><td>type of precision parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">phi</td><td>(Sequence of) precision parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../db/dfc/opencl_2prim_2neg__binomial__2__lpmf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../db/dfc/opencl_2prim_2neg__binomial__2__lpmf_8hpp_source.html">neg_binomial_2_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaacb77966b5ca780cac193dfeb6e7dc7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_n_cl, T_shape_cl, T_inv_scale_cl&gt; stan::math::neg_binomial_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s). </p>
<p>n, alpha, or beta can each be either a scalar or a vector <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_inv_scale_cl</td><td>type of precision parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) precision parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/d45/opencl_2prim_2neg__binomial__lpmf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d1/d45/opencl_2prim_2neg__binomial__lpmf_8hpp_source.html">neg_binomial_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf3c799735f974356f8d1ab7743960a65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl&gt; stan::math::normal_id_glm_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_sigma_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function. </p>
<p>If containers are supplied, returns the log sum of the probabilities. This is an overload of the GLM in <a class="el" href="../../de/d31/prim_2prob_2normal__id__glm__lpdf_8hpp.html">prim/prob/normal_id_glm_lpdf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a (optionally <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a></code> containing) <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> column vector (of the same length as y) of intercepts or a scalar (for models with constant intercept) </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; (optionally <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a></code> containing) <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> column vector </td></tr>
    <tr><td class="paramname">T_sigma_cl</td><td>type of the (positive) scale(s); (optionally <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a></code> containing) <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> column vector (of the same length as y, for heteroskedasticity) or a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/dc0/opencl_2prim_2normal__id__glm__lpdf_8hpp_source.html#l00063">63</a> of file <a class="el" href="../../d1/dc0/opencl_2prim_2normal__id__glm__lpdf_8hpp_source.html">normal_id_glm_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab98a15165135ddb986e4f74cb66817ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl&gt; stan::math::normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s). </p>
<p>y, mu, or sigma can each be either a scalar or a vector <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) for the normal distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d2f/opencl_2prim_2normal__lpdf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../dd/d2f/opencl_2prim_2normal__lpdf_8hpp_source.html">normal_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga363eead878eb45fb01517e94ac7d4f4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x, T_beta, T_cuts&gt; stan::math::ordered_logistic_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_cuts &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the ordinal regression Generalized Linear Model (GLM). </p>
<p>This is equivalent to and faster than ordered_logistic_lpmf(y, x * beta, cuts). This is an overload of the GLM in <a class="el" href="../../da/d4f/prim_2prob_2ordered__logistic__glm__lpmf_8hpp.html">prim/prob/ordered_logistic_glm_lpmf.hpp</a> that is implemented in OpenCL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_beta</td><td>type the vector of weights </td></tr>
    <tr><td class="paramname">T_cuts</td><td>type the vector of cutpoints </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>a scalar or vector of classes on OpenCL device. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix or row vector on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">cuts</td><td>cutpoints vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If any class is not between 1 and the number of cutpoints plus 2 or if the cutpoint vector is not sorted in ascending order or any input is not finite </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d9/dbc/opencl_2prim_2ordered__logistic__glm__lpmf_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../d9/dbc/opencl_2prim_2ordered__logistic__glm__lpmf_8hpp_source.html">ordered_logistic_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga490df7651c22c9e06d09da69ad303e30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::packed_copy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packs the square flat triangular matrix on the OpenCL device and copies it to the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the flat triangular source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packed std::vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not triangular </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00141">141</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaed1f7da1a49ff3c2a9e1147b4eef4662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;Vec_scalar&gt; stan::math::packed_copy </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device. </p>
<p>If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">matrix_view</td><td>the triangularity of the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the packed source std::vector </td></tr>
    <tr><td class="paramname">rows</td><td>the number of rows in the flat matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the destination flat matrix on the OpenCL device </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the size of the vector does not match the expected size for the packed triangular matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00193">193</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b5e8eec1c27b30ea994f94070adc148"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s). </p>
<p>y, y_min, or alpha can each either be scalar a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/y_min/alpha triple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar outcome </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">y_min</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d28/opencl_2prim_2pareto__lpdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="../../dd/d28/opencl_2prim_2pareto__lpdf_8hpp_source.html">pareto_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga83a333811247fce0ea707ce959dffa38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::pareto_type_2_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Pareto type 2 distribution. </p>
<p>If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of dependent variable </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of inverse scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>dependent variable </td></tr>
    <tr><td class="paramname">mu</td><td>location </td></tr>
    <tr><td class="paramname">lambda</td><td>scale </td></tr>
    <tr><td class="paramname">alpha</td><td>inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is NaN, mu is infinite, lambda is negative or infinite or alpha is negative or infinite. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/da0/opencl_2prim_2pareto__type__2__lpdf_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../da/da0/opencl_2prim_2pareto__type__2__lpdf_8hpp_source.html">pareto_type_2_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacd6c49794202989a029ff70567f55479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_x_cl, T_alpha_cl, T_beta_cl&gt; stan::math::poisson_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_x_cl &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function. </p>
<p>This is an overload of the GLM in <a class="el" href="../../d3/dd2/prim_2prob_2poisson__log__glm__lpmf_8hpp.html">prim/prob/poisson_log_glm_lpmf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of independent variable; this can be a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> vector of intercepts or a single value (wich will be broadcast - used for all instances); </td></tr>
    <tr><td class="paramname">T_x_cl</td><td>type of the design matrix </td></tr>
    <tr><td class="paramname">T_alpha_cl</td><td>type of the intercept(s); this can be a <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code> vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta_cl</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>positive integer scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/dbf/opencl_2prim_2poisson__log__glm__lpmf_8hpp_source.html#l00054">54</a> of file <a class="el" href="../../dc/dbf/opencl_2prim_2poisson__log__glm__lpmf_8hpp_source.html">poisson_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b1dba179f6258a2e07a30bdbe97255a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_log_rate_cl&gt; stan::math::poisson_log_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_rate_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Poisson log distribution. </p>
<p>If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of integer parameters </td></tr>
    <tr><td class="paramname">T_log_rate_cl</td><td>type of chance of success parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>integer parameter </td></tr>
    <tr><td class="paramname">alpha</td><td>log rate parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/d28/opencl_2prim_2poisson__log__lpmf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d7/d28/opencl_2prim_2poisson__log__lpmf_8hpp_source.html">poisson_log_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabfdbbaacbab1d90d71290edc806bace3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n_cl , typename T_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_rate_cl&gt; stan::math::poisson_lpmf </td>
          <td>(</td>
          <td class="paramtype">const T_n_cl &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate_cl &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Poisson distribution. </p>
<p>If containers are supplied, returns the log sum of the probabilities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_n_cl</td><td>type of integer parameters </td></tr>
    <tr><td class="paramname">T_rate_cl</td><td>type of chance of success parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>integer parameter </td></tr>
    <tr><td class="paramname">lambda</td><td>rate parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if lambda is not a valid probability </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/df5/opencl_2prim_2poisson__lpmf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d8/df5/opencl_2prim_2poisson__lpmf_8hpp_source.html">poisson_lpmf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga601d163c824e05147660da53e4099bd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_scale_cl&gt; stan::math::rayleigh_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an Rayleigh density for y with the specified scale parameter. </p>
<p>y and scale parameter must be greater than 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of inverse scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">sigma</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/de1/opencl_2prim_2rayleigh__lpdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../dc/de1/opencl_2prim_2rayleigh__lpdf_8hpp_source.html">rayleigh_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga480e7b2d228e7bb71d6160c87349464a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;T&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> by replicating the value of the only element in the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. </p>
<p>The element must be of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the results matrix </td></tr>
    <tr><td class="paramname">m</td><td>number of columns in the results matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if input element is not a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> of size 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9619e09e2ee9450bbcc70f11a8076668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;T&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> by replicating the input vector or row_vector. </p>
<p>The elements of the vector or row_vector must be of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> (vector or row_vector) </td></tr>
    <tr><td class="paramname">m</td><td>number of rows (if x is a row_vector) or columns (if x is a vector) in the results matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result matrix with replicated rows or columns</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5f940240b9c947f73f5871c9fbaed378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;T&gt; stan::math::rep_row_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> representing a row_vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> </td></tr>
    <tr><td class="paramname">m</td><td>number of columns in the results vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if input element is not a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> of size 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/dc5/opencl_2prim_2rep__row__vector_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../dd/dc5/opencl_2prim_2rep__row__vector_8hpp_source.html">rep_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c5cacb7a3b780ce375aec0449229e03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;T&gt; stan::math::rep_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> representing a vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input 1x1 <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in the results row_vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if input element is not a <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> of size 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/dcd/opencl_2prim_2rep__vector_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../df/dcd/opencl_2prim_2rep__vector_8hpp_source.html">rep_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga80392ae5670adea53e79770aa29c816a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::row </td>
          <td>(</td>
          <td class="paramtype">T_x &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified row of the specified kernel generator expression using start-at-1 indexing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression x </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression. </td></tr>
    <tr><td class="paramname">j</td><td>Row index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified row of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if j is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/d8f/opencl_2prim_2row_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d8/d8f/opencl_2prim_2row_8hpp_source.html">row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga61254f29c1520f4bffe4ab4e5bbd0e0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::rows </td>
          <td>(</td>
          <td class="paramtype">const T_x &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the specified kernel generator expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_x</td><td>type of input kernel generator expression x </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input kernel generator expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of rows in x </dd></dl>

<p>Definition at line <a class="el" href="../../de/dd4/opencl_2prim_2rows_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../de/dd4/opencl_2prim_2rows_8hpp_source.html">rows.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga106d028bb360d5c31554ec3495cc41d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_dof_cl, T_scale_cl&gt; stan::math::scaled_inv_chi_square_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter. </p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Inv-}}\chi^2(\nu, s^2) \\ \log (p (y \, |\, \nu, s)) &amp;=&amp; \log \left( \frac{(\nu / 2)^{\nu / 2}}{\Gamma (\nu / 2)} s^\nu y^{- (\nu / 2 + 1)} \exp^{-\nu s^2 / (2y)} \right) \\ &amp;=&amp; \frac{\nu}{2} \log(\frac{\nu}{2}) - \log (\Gamma (\nu / 2)) + \nu \log(s) - (\frac{\nu}{2} + 1) \log(y) - \frac{\nu s^2}{2y} \\ &amp; &amp; \mathrm{ where } \; y &gt; 0 \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of random variable </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
    <tr><td class="paramname">T_Scale_cl</td><td>type of scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>random variable </td></tr>
    <tr><td class="paramname">nu</td><td>degrees of freedom </td></tr>
    <tr><td class="paramname">s</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if s is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d70/opencl_2prim_2scaled__inv__chi__square__lpdf_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d5/d70/opencl_2prim_2scaled__inv__chi__square__lpdf_8hpp_source.html">scaled_inv_chi_square_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac950822e01ad7173a9f42c571933eb06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl&gt; stan::math::skew_normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the skew normal density for the specified scalar(s) given the specified mean(s), deviation(s) and shape(s). </p>
<p>y, mu, sigma, or alpha can each be either a scalar or a vector <a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a>. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation quadruple.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameter(s) </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) shape parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/dfa/opencl_2prim_2skew__normal__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d7/dfa/opencl_2prim_2skew__normal__lpdf_8hpp_source.html">skew_normal_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga48200e7b64861fad93fcdf7b24c8cac4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl&gt; stan::math::std_normal_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the normal density for the specified scalar(s) given a location of 0 and a scale of 1. </p>
<p>y can be either a scalar or a vector.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Sequence of scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if any scalar is nan. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/d83/opencl_2prim_2std__normal__lpdf_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../d2/d83/opencl_2prim_2std__normal__lpdf_8hpp_source.html">std_normal_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a3e85cdcb831735bf845adf1c42e234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl&gt; stan::math::student_t_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof_cl &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc_cl &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of the Student-t density for the given y, nu, mean, and scale parameter. </p>
<p>The scale parameter must be greater than 0.</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; t_{\nu} (\mu, \sigma^2) \\ \log (p (y \, |\, \nu, \mu, \sigma) ) &amp;=&amp; \log \left( \frac{\Gamma((\nu + 1) /2)} {\Gamma(\nu/2)\sqrt{\nu \pi} \sigma} \left( 1 + \frac{1}{\nu} (\frac{y - \mu}{\sigma})^2 \right)^{-(\nu + 1)/2} \right) \\ &amp;=&amp; \log( \Gamma( (\nu+1)/2 )) - \log (\Gamma (\nu/2) - \frac{1}{2} \log(\nu \pi) - \log(\sigma) -\frac{\nu + 1}{2} \log (1 + \frac{1}{\nu} (\frac{y - \mu}{\sigma})^2) \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_dof_cl</td><td>type of degrees of freedom </td></tr>
    <tr><td class="paramname">T_loc_cl</td><td>type of location </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
    <tr><td class="paramname">mu</td><td>The mean of the Student-t distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>The scale parameter of the Student-t distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Student-t density at y. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d73/opencl_2prim_2student__t__lpdf_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d4/d73/opencl_2prim_2student__t__lpdf_8hpp_source.html">student_t_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga46313382ff3fae62c662662f93290572"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">var_value&lt;matrix_cl&lt;value_type_t&lt;T&gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source var containing <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices to destination var that has data stored on the OpenCL device. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the OpenCL device </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab445d52648b5e23086af72eb1c023ddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_vt_arithmetic&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix_cl&lt;value_type_t&lt;T&gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, <code>std::vector</code> or scalar to the destination matrix that is stored on the OpenCL device. </p>
<p>The function also accepts <code><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a></code>s in which case it just returns the argument. If a lvalue matrix is passed to this function the caller must make sure that the matrix does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c8837ecfc67bc2624979c3633d76411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">var_value&lt;matrix_cl&lt;value_type_t&lt;T&gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d4/d84/namespacestan_1_1math.html#d1/dea/classstan_1_1math_1_1var__value">var_value</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source std::vector of vars to a destination var that has data stored on the OpenCL device. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>var with a copy of the data on the OpenCL device </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00048">48</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga095903e22c477b60e69e174c307bd423"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">var_value&lt;matrix_cl&lt;value_type_t&lt;value_type_t&lt;T&gt; &gt; &gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix of vars to the destination matrix that is stored on the OpenCL device. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Compile time rows of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
    <tr><td class="paramname">C</td><td>Compile time columns of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d3/d34/group__matrix__cl__group.html#df/d15/classstan_1_1math_1_1matrix__cl">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html#l00085">85</a> of file <a class="el" href="../../d5/d25/rev_2copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafccee2b081b9edd7c6e6d211157e5490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const matrix_cl_view stan::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes a view - swaps lower and upper parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to transpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposition of input </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga57ff9a795bfa5ae75421d00a95e8a6c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , require_matrix_cl_st&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plain_type_t&lt;T&gt; stan::math::tri_inverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse of a triangular matrix. </p>
<p>For a full guide to how this works and fits into Cholesky decompositions, see the reference report <a href="https://github.com/SteveBronder/stancon2018/blob/master/report.pdf">here</a> and kernel doc <a href="https://github.com/stan-dev/math/wiki/GPU-Kernels">here</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of A</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/dfb/tri__inverse_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d4/dfb/tri__inverse_8hpp_source.html">tri_inverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c081c9922500bedd293b98080c246a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_low_cl, T_high_cl&gt; stan::math::uniform_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high_cl &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log of a uniform density for the given y, lower, and upper bound. </p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{U}}(\alpha, \beta) \\ \log (p (y \, |\, \alpha, \beta)) &amp;=&amp; \log \left( \frac{1}{\beta-\alpha} \right) \\ &amp;=&amp; \log (1) - \log (\beta - \alpha) \\ &amp;=&amp; -\log (\beta - \alpha) \\ &amp; &amp; \mathrm{ where } \; y \in [\alpha, \beta], \log(0) \; \mathrm{otherwise} \end{eqnarray*}
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of scalar </td></tr>
    <tr><td class="paramname">T_low_cl</td><td>type of lower bound </td></tr>
    <tr><td class="paramname">T_high_cl_cl</td><td>type of upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">beta</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the lower bound is greater than or equal to the lower bound </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/ddb/opencl_2prim_2uniform__lpdf_8hpp_source.html#l00042">42</a> of file <a class="el" href="../../d7/ddb/opencl_2prim_2uniform__lpdf_8hpp_source.html">uniform_lpdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ecf070a86a3bb30c08ced16a1c1bb32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type_t&lt;T_y_cl, T_shape_cl, T_scale_cl&gt; stan::math::weibull_lpdf </td>
          <td>(</td>
          <td class="paramtype">const T_y_cl &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape_cl &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_cl &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Weibull log probability density for the given location and scale. </p>
<p>Given containers of matching sizes, returns the log sum of probability densities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y_cl</td><td>type of real parameter </td></tr>
    <tr><td class="paramname">T_shape_cl</td><td>type of shape parameter </td></tr>
    <tr><td class="paramname">T_scale_cl</td><td>type of scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>real parameter </td></tr>
    <tr><td class="paramname">alpha</td><td>shape parameter </td></tr>
    <tr><td class="paramname">sigma</td><td>scale parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability density or log sum of probability densities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is negative, alpha or sigma are nonpositive </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/db8/opencl_2prim_2weibull__lpdf_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../d4/db8/opencl_2prim_2weibull__lpdf_8hpp_source.html">weibull_lpdf.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
